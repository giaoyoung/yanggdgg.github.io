<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		JVM | 
	 
	Young&#39;s blog
	</title>
	
	<!-- keywords,description -->
	
		<meta name="keywords" content="Java" />
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "wujun234.com";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Young's blog</a>

	<ul id="menu">
    

    

    

    
      
      
        <li class="menu-item">
          <a href='https://github.com/wujun234/hexo-theme-tree' class="menu-item-link" target="_blank">
            Tree
          </a>
        </li>
      
        <li class="menu-item">
          <a href='https://github.com/wujun234/uid-generator-spring-boot-starter' class="menu-item-link" target="_blank">
            UidGenerator
          </a>
        </li>
      
    
  
    
      <li class="menu-item">
        <a href='https://github.com/wujun234' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file active">
									<a href="/2023/09/05/JVM/">
                     
										    JVM
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/09/04/My-new-Post/">
                     
										    My new Post
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/09/01/hello-world/">
                     
										    Hello World
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	JVM
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>Young</span>
	<span>2023-09-05 21:17:14</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<h1 id="一、JVM简介"><a href="#一、JVM简介" class="headerlink" title="一、JVM简介"></a>一、JVM简介</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>JVM（Java Virtual Machine）全称：Java虚拟机</p>
<p>JVM并不是真实的计算机，而是在真实计算机中的一个进程，是虚拟出来的一台计算机。</p>
<p>所有的Java程序都是在JVM中运行的。JVM形成了对Java程序的保护。</p>
<p>只要平台(系统)能运行JVM就能运行Java程序，且Java程序运行环境是一样的，与外部平台没有关系。</p>
<p>所以Java程序可以跨平台、安全。</p>
<h1 id="二、JVM规范与具体实现"><a href="#二、JVM规范与具体实现" class="headerlink" title="二、JVM规范与具体实现"></a>二、JVM规范与具体实现</h1><h2 id="1-官方文档"><a href="#1-官方文档" class="headerlink" title="1.官方文档"></a>1.官方文档</h2><p>官方文档地址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a> </p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902111036052.png" alt="image-20230902111036052"></p>
<p>在Java官方文档中，每个版本官方都提供了两个版本的文档地址。</p>
<h2 id="2-什么是规范"><a href="#2-什么是规范" class="headerlink" title="2. 什么是规范"></a>2. 什么是规范</h2><p>Oracle官方通过文字说明，某个版本的JVM应该如何去实现、应该包含哪些内容，这些规定就是规范。</p>
<h2 id="3-我们使用的是哪种虚拟机"><a href="#3-我们使用的是哪种虚拟机" class="headerlink" title="3.我们使用的是哪种虚拟机"></a>3.我们使用的是哪种虚拟机</h2><p><strong>HotSpot虚拟机</strong></p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902111420198.png" alt="image-20230902111420198"></p>
<p>在HotSpot实现过程中也提供一些参数，让开发者可以调试它（所谓的JVM调优其实就是调整设置这些参数）。</p>
<p>HotSpot：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<h2 id="4-一些主流的JVM规范具体实现"><a href="#4-一些主流的JVM规范具体实现" class="headerlink" title="4.一些主流的JVM规范具体实现"></a>4.一些主流的JVM规范具体实现</h2><table>
<thead>
<tr>
<th>JVM名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HotSpot</td>
<td>Oracle官方对JVM规范的实现</td>
</tr>
<tr>
<td>jRocket</td>
<td>曾经JVM的扛把子，号称最快的虚拟机，后被Oracle收购，和HotSpot整合</td>
</tr>
<tr>
<td>J9</td>
<td>IBM对JVM规范的实现</td>
</tr>
<tr>
<td>TaobaoVM</td>
<td>HotSpot深度定制版</td>
</tr>
<tr>
<td>azul zing</td>
<td>商业收费版</td>
</tr>
</tbody></table>
<h1 id="三、类加载机制-类的生命周期（面）"><a href="#三、类加载机制-类的生命周期（面）" class="headerlink" title="三、类加载机制&#x2F;类的生命周期（面）"></a>三、类加载机制&#x2F;类的生命周期（面）</h1><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1.类加载器"></a>1.类加载器</h2><p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902112106858.png" alt="image-20230902112106858"></p>
<h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>类加载器就是把class文件加载到JVM中去</p>
<p>类加载器本身就是一个Java类，所以也需要被加载，这由启动类加载器Bootstrap ClassLoader来完成（C&#x2F;C++写的本地的类加载器）</p>
<p>它是JVM的内核，无需再被类加载器加载。</p>
<img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\image-20230902112126739.png" alt="image-20230902112126739" style="zoom:80%;" />



<h3 id="1-2-加载"><a href="#1-2-加载" class="headerlink" title="1.2 加载"></a>1.2 加载</h3><img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\image-20230902135805647.png" alt="image-20230902135805647" style="zoom: 67%;" />

<p>1.启动类加载器(Bootstrap ClassLoader) 是优先级最高的加载器，最先进行加载。负责加载JDK目录&#x2F;jre&#x2F;lib 中相关的jar包。包含了所有的核心类。</p>
<p>如：String、System等</p>
<p>2.扩展类加载器(Extension ClassLoader):负责加载扩展类。具体就是JDK目录&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>3.应用程序加载器(Application ClassLoader)负责加载类路径中字节码文件，也就是classpath中的内容。</p>
<p><strong>总结：</strong></p>
<p>​	类加载器加载的都是class文件，加载到JVM中。</p>
<p>​		启动类加载器加载 核心jar包</p>
<p>​		扩展类加载器加载拓展类</p>
<p>​		应用程序加载器加载自己写的类</p>
<h3 id="1-3-链接（Linking"><a href="#1-3-链接（Linking" class="headerlink" title="1.3 链接（Linking)"></a>1.3 链接（Linking)</h3><p>1.<strong>校验</strong>（verify)：校验加载的字节码文件是否正确。</p>
<p>进行4 个阶段的校验：</p>
<p>​	①文件格式校验</p>
<p>​	②元数据校验</p>
<p>​	③字节码验证</p>
<p>​	④符号引用验证</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902140659803.png" alt="image-20230902140659803"></p>
<p>2.<strong>准备</strong>（prepare）：所有静态变量初始化（分配空间）并赋予<strong>默认值</strong>。</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902140836132.png" alt="image-20230902140836132"></p>
<p><strong>注意点</strong>：实例变量此时还没有分配内存；若静态变量被final修饰，不再赋予默认值而是赋开发者指定的值。</p>
<p>（1）该阶段进行的内存分配仅包括类的静态变量（static），不包括实例变量；实例变量是在对象被实例化时随着对象一起被分配在JVM的堆中。</p>
<p>（2）静态变量初始赋值通常是数据类型对应的默认值，而不是代码中赋的值</p>
<p>​				①基本数据类型：对于静态变量（static）和全局变量，会为其赋予默认值。而局部变量使用前都必须显示的在代码中赋值，否则编译时不通过。</p>
<p>​				②同时被static和final修饰的常量，必须在声明的时候就在代码中显式的为其赋值，否则编译时不同过；</p>
<p>​					而只被final修饰的常量则可以声明时显式赋值，也可以在类初始化时显示赋值，总之使用前必须赋值，因为系统不会为其赋默认值。</p>
<p>​				③引用数据类型：没有显示赋值就会被赋予默认值null</p>
<p>​				④如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素会根据各自的数据类型而被赋予对应的默认值。</p>
<p>3.<strong>解析</strong>（resolve）：把符号引用转换为直接引用。</p>
<p>​	（1）实例变量不在该阶段分配内存</p>
<p>​	（2）因为类方法和私有方法符合”<strong>编译器可知、运行期不可变</strong>“的要求，即不会被继承或重写，所以适合在类加载过程中解析。</p>
<p>​	（3）若类变量为常量（final修饰），则直接赋值为开发者定义的值。</p>
<p><strong>符号引用</strong></p>
<p>​		比如程序中的main方法，写法是固定的，我们可以把它当做一个符号。</p>
<p>​		这些符号被加载到JVM中都会对应一个地址，“将符号引用转换为直接引用”指的就是：将这些符号转变成对应的地址，这些地址就是直接引用。根据这些地址能真正的对数据进行操作。</p>
<h3 id="1-4-初始化（Initialization）"><a href="#1-4-初始化（Initialization）" class="headerlink" title="1.4 初始化（Initialization）"></a>1.4 <strong>初始化</strong>（Initialization）</h3><p>​		执行静态代码块和静态变量赋值。</p>
<h3 id="1-5-运行"><a href="#1-5-运行" class="headerlink" title="1.5 运行"></a>1.5 <strong>运行</strong></h3><p>​		运行字节码文件。</p>
<h3 id="1-6-卸载"><a href="#1-6-卸载" class="headerlink" title="1.6 卸载"></a>1.6 卸载</h3><p>​		运行结束后进行卸载。</p>
<h1 id="四、类加载器源码分析"><a href="#四、类加载器源码分析" class="headerlink" title="四、类加载器源码分析"></a>四、类加载器源码分析</h1><h2 id="1-Launcher类介绍"><a href="#1-Launcher类介绍" class="headerlink" title="1.Launcher类介绍"></a>1.Launcher类介绍</h2><p>sun.misc.Launcher是JVM的入口类</p>
<p>全局属性如下：</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902144542375.png" alt="image-20230902144542375"></p>
<h2 id="2-ClassLoader类"><a href="#2-ClassLoader类" class="headerlink" title="2.ClassLoader类"></a>2.ClassLoader类</h2><h3 id="2-1-parent属性"><a href="#2-1-parent属性" class="headerlink" title="2.1 parent属性"></a>2.1 parent属性</h3><p>ClassLoader是Java提供的类加载器的父类。</p>
<p>所有类加载器都是这个类的子类或子孙类。</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902144849034.png" alt="image-20230902144849034"></p>
<p>提供了全局变量属性parent，这意味着类加载器之间具有<strong>逻辑父子关系</strong>（并不是继承关系）</p>
<h3 id="2-2-native关键字"><a href="#2-2-native关键字" class="headerlink" title="2.2 native关键字"></a>2.2 native关键字</h3><p>Java中除了abstract 修饰的方法没有方法体，native修饰的方法也没有方法体。</p>
<p>native修饰的方法表示该方法具体实现是通过其他语言进行实现的。</p>
<p>Java在操作内存或硬件多用C&#x2F;C++进行实现，而这些方法都需要通过native修饰。</p>
<h2 id="3-加载器的父子关系"><a href="#3-加载器的父子关系" class="headerlink" title="3.加载器的父子关系"></a>3.加载器的父子关系</h2><h3 id="3-1-获取类加载器"><a href="#3-1-获取类加载器" class="headerlink" title="3.1 获取类加载器"></a>3.1 获取类加载器</h3><p>可以通过：类名.class.getClassLoader()进行查看类是由哪种加载器进行加载的。</p>
<p>​				getClassLoader() 返回值为ClassLoader类对象。</p>
<h3 id="3-2-获取父加载器"><a href="#3-2-获取父加载器" class="headerlink" title="3.2 获取父加载器"></a>3.2 获取父加载器</h3><p>ClassLoader中包含getParent()方法，表示获取当前加载器的父加载器。</p>
<h3 id="3-3-为什么ExtClassLoader的父加载器是null"><a href="#3-3-为什么ExtClassLoader的父加载器是null" class="headerlink" title="3.3 为什么ExtClassLoader的父加载器是null"></a>3.3 为什么ExtClassLoader的父加载器是null</h3><p>类加载器的逻辑父子关系 ：从上到下为由父到子</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902150426984.png" alt="image-20230902150426984"></p>
<p>为什么ExtClassLoader获取的父加载器不是BootstrapCalssLoader而是null呢？</p>
<p>在Launcher中并没有BootstrapClassLoader类。因为Java中并没有提供BootstrapClassLoader类，而是通过C&#x2F;C++语言编写的。既然Java中没有这个类所以我们在获取ExtClassLoader的父加载器时自然为null。</p>
<p>但是这三个加载器依然是具有逻辑父子关系的（再次强调：不是继承）。</p>
<h2 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4. 双亲委派机制"></a>4. 双亲委派机制</h2><p>代码体现在java.lang.ClassLoader中的loadClass()方法</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902151843636.png" alt="image-20230902151843636">1.委派的过程就是一层一层向上找的过程，只要当前加载器加载过该类就不会重新加载，没有加载过就向上寻找是否加载过。</p>
<p>2.当委派到Bootstrap ClassLoader后就一层一层向下判断是否能加载该类，能则加载，不能就继续向下寻找类加载器是否能加载，到最后一层都无法加载时就会抛出ClassNotFoundException异常。</p>
<p>好处：避免核心类被恶意代码通过自定义的类加载器篡改核心类库的类</p>
<p>​			类只被加载一次，保证了类的一致性。</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902153113546.png" alt="image-20230902153113546"></p>
<h1 id="五、JVM内存结构（面）"><a href="#五、JVM内存结构（面）" class="headerlink" title="五、JVM内存结构（面）"></a>五、JVM内存结构（面）</h1><h2 id="1-JVM内存问题"><a href="#1-JVM内存问题" class="headerlink" title="1.JVM内存问题"></a>1.JVM内存问题</h2><p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902153523309.png" alt="image-20230902153523309"></p>
<h2 id="2-源文件"><a href="#2-源文件" class="headerlink" title="2. 源文件"></a>2. 源文件</h2><p>源文件就是我们编写的java代码的文件，扩展名为.java。</p>
<h2 id="3-字节码文件"><a href="#3-字节码文件" class="headerlink" title="3.字节码文件"></a>3.字节码文件</h2><p>字节码文件是源文件经编译得到的文件，字节码文件是二进制文件，需要通过特定的工具才能查看，里面存放了源文件编译后的字节码指令。</p>
<h2 id="4-类加载器Class-Loader"><a href="#4-类加载器Class-Loader" class="headerlink" title="4.类加载器Class Loader"></a>4.类加载器Class Loader</h2><p>Java 程序运行时会由类加载器负责把.class的字节码文件装在到内存中，供虚拟机执行。</p>
<h4 id="4-1-加载-Loading"><a href="#4-1-加载-Loading" class="headerlink" title="4.1 加载 Loading"></a>4.1 加载 Loading</h4><ol>
<li><p><strong>启动类加载器 BootStrap Class Loader</strong></p>
<p>负责从启动类中加载类。具有最高执行优先级。即：rt.jar等。</p>
</li>
<li><p><strong>扩展类加载器 Extension Class Loader</strong></p>
<p>负责加载扩展相关类。即：jre&#x2F;lib&#x2F;ext 目录。</p>
</li>
<li><p><strong>应用程序加载器 Application Class Loader</strong></p>
<p>加载应用程序类路径(classpath)中相关类。</p>
</li>
</ol>
<h4 id="4-2-链接-Linking"><a href="#4-2-链接-Linking" class="headerlink" title="4.2 链接 Linking"></a>4.2 链接 Linking</h4><ol>
<li><strong>校验 Verify</strong></li>
</ol>
<p>​	校验器会校验字节码文件是否正确。</p>
<ol start="2">
<li><strong>准备 Prepare</strong></li>
</ol>
<p>​	所有静态变量初始化并赋予默认值。</p>
<ol start="3">
<li><strong>解析 Resolve</strong></li>
</ol>
<p>​	符号引用被换成直接引用。</p>
<h4 id="4-3-初始化-Initialization"><a href="#4-3-初始化-Initialization" class="headerlink" title="4.3 初始化 Initialization"></a>4.3 <strong>初始化 Initialization</strong></h4><p>所有静态变量赋予初值，静态代码块执行。</p>
<h2 id="5-执行引擎"><a href="#5-执行引擎" class="headerlink" title="5. 执行引擎"></a>5. 执行引擎</h2><p>运行时数据区的字节码会交给执行引擎执行。</p>
<h3 id="5-1-解释器-Interpreter"><a href="#5-1-解释器-Interpreter" class="headerlink" title="5.1 解释器 Interpreter"></a>5.1 <strong>解释器 Interpreter</strong></h3><p>解释器负责解释字节码文件。每次方法调用都会被重新解释。</p>
<h3 id="5-2-JIT编译器"><a href="#5-2-JIT编译器" class="headerlink" title="5.2 JIT编译器"></a>5.2 JIT编译器</h3><p>Java程序在运行的时候，主要就是执行字节码指令，一般这些指令会通过解释器（Interpreter）进行解释执行，这种就是解释执行。</p>
<p>当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为 热点代码。为了提高热点代码的执行效率，在运行时虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，简称 JIT 编译器）。</p>
<h3 id="5-3-探测器"><a href="#5-3-探测器" class="headerlink" title="5.3 探测器"></a>5.3 探测器</h3><p>负责探测多次被调用的代码。</p>
<h3 id="5-4-垃圾回收器-GC"><a href="#5-4-垃圾回收器-GC" class="headerlink" title="5.4 垃圾回收器 GC"></a>5.4 垃圾回收器 GC</h3><p>负责回收不在被使用的对象。GC是JVM中非常重要的一块，在后面我们会单独讲解GC。</p>
<h2 id="6-本地库接口"><a href="#6-本地库接口" class="headerlink" title="6. 本地库接口"></a>6. 本地库接口</h2><p>在Java代码中使用native修饰的方法表示方法具体实现使用其他编程语言实现的。例如：C语言。通过本地库接口为Java程序提供调用其他语言的实现方案。</p>
<h2 id="7-本地方法库"><a href="#7-本地方法库" class="headerlink" title="7. 本地方法库"></a>7. 本地方法库</h2><p>所有的本地方法，通过本地库接口调用。</p>
<h2 id="8-程序计数器"><a href="#8-程序计数器" class="headerlink" title="8. 程序计数器"></a>8. 程序计数器</h2><p>程序计数器简称：PC Register。</p>
<p>程序计数器是一块较小的内存空间。记录了当前线程执行到的字节码行号。每个线程都有自己的程序计数器，相互不影响。如果是native方法，计数器为空。</p>
<h2 id="9-虚拟机栈"><a href="#9-虚拟机栈" class="headerlink" title="9. 虚拟机栈"></a>9. 虚拟机栈</h2><p>虚拟机栈跟随线程创建而创建，所以每个线程都有一个虚拟机栈。</p>
<p>虚拟机栈中存储的是栈帧（frames），每个栈帧对应一个方法，每个栈帧都有自己的局部变量表、操作数栈、动态链接和返回地址等。当前正在执行的方法称为当前方法，当前方法所在的帧称为当前帧。方法执行时帧就是一个入栈操作，方法执行完成之后栈帧就是一个出栈操作。</p>
<h3 id="9-1-局部变量表"><a href="#9-1-局部变量表" class="headerlink" title="9.1 局部变量表"></a><strong>9.1</strong> <strong>局部变量表</strong></h3><p>局部变量表存储的8大基本数据类型和返回值以及方法参数及对象的引用。	其中long和double占用2倍长度。</p>
<p>局部变量表就是一个数组，数组的长度在编译期确定。通过从0开始的索引调用局部变量表的内容。</p>
<h3 id="9-2-操作数栈"><a href="#9-2-操作数栈" class="headerlink" title="9.2 操作数栈"></a><strong>9.2</strong> 操作数栈</h3><p>操作数栈存在于栈帧中，其大小在编译期确定。</p>
<p>操作数栈中存储了class文件中虚拟机指令以及准备要传递的参数和接收对方的返回结果。</p>
<p>运行时常量池中数据以及局部变量表中得值都可以由操作数栈进行获取。</p>
<h3 id="9-3-动态链接"><a href="#9-3-动态链接" class="headerlink" title="9.3 动态链接"></a><strong>9.3</strong> 动态链接</h3><p>符号引用转换为直接引用分为两种情况。</p>
<p>在JVM加载或第一次使用转换时称为静态链接或静态解析。而在运行期间把符号转换为直接引用时就称为动态链接。</p>
<h3 id="9-4-方法返回地址"><a href="#9-4-方法返回地址" class="headerlink" title="9.4 方法返回地址"></a><strong>9.4</strong> 方法返回地址</h3><p>方法返回地址分为两种情况：</p>
<p>​	1. 正常结束执行。例如碰见return关键字。调用程序计数器的值后当前栈帧直接出栈就可以了。</p>
<p>​	2. 异常结束。可能需要恢复上层方法的局部变量表和操作数栈，然后把返回值压如到栈帧的操作数栈中，之后调用程序计数器的值后获取到下条指令。</p>
<h2 id="10-堆"><a href="#10-堆" class="headerlink" title="10. 堆"></a>10. 堆</h2><p>堆是所有线程共享的，存储类的实例和数组。</p>
<p>堆是在虚拟机启动时创建的，由GC负责回收。</p>
<p>堆可以是一块不连续的内存空间。</p>
<p>在Java 8 中，String是存在于堆中的。</p>
<p>堆被分为二大部分：</p>
<p>​	在Java 7时分为：新生代（Young Generation）、老年代（Old Generation）、永久代。且新生代、老年代和永久代是连续的。</p>
<p>​	新生代又被分为Eden区、From Survivor区、To Survivor区。官方说明默认分配比例为8：1：1。但是使用jmap工具进行测试时发现比例为6：1：1。</p>
<p>​	在Java 8时把永久代替换为元空间（MetaSpace），也就是说在Java8中使用元空间来实现方法区。且在Java8中把元空间移植到本地内存上（Native Memory），其实在Java 7 时，部分数据已经移植到本地内存上了。例如：符号引用(Symbols)。</p>
<p>字符串常量池在堆中。</p>
<h2 id="11-方法区"><a href="#11-方法区" class="headerlink" title="11. 方法区"></a>11. 方法区</h2><p>方法区是线程共享的。</p>
<p>在虚拟机启动时自动创建方法区，方法区可以是一块不连续的内存空间。<br>​方法区可以理解为编译代码存储区。在方法区中存储每个类的结构、运行时常量池、字段、方法、构造方法。</p>
<p> 在JVM规范上方法区是一个独立的区域，但是在Java SE7 的HotSpot 上方法区使用永久代作为实现，永久代和堆是一块连续空间。在Java SE8的JVM规范实现上，HotSpot使用元空间（本地内存）实现方法区。</p>
<h1 id="六、GC垃圾回收器"><a href="#六、GC垃圾回收器" class="headerlink" title="六、GC垃圾回收器"></a>六、GC垃圾回收器</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>垃圾回收器（ <a target="_blank" rel="noopener" href="http://www.baidu.com/link?url=uf7Y-Bly_9Nw5E8N6mYu_vTMYYAw_l4U0PDFUtEdaAAKH9xDDKpmxOrm2qmGES7dXBgxcnU3N_TYgRxQjyLlLGiZ54BztjrVqDXAB68IT5dvZg8m1wIX-sY_7g6MMSYy">garbage collection</a>，简称GC）负责回收JVM运行时数据区的<strong>堆内存</strong>和<strong>方法区</strong>中数据。而虚拟机栈、程序计数器、本地方法栈都是根据线程创建而创建，随着线程销毁而销毁，所以不需要进行回收。</p>
<h2 id="2-GC判断对象是否可以回收"><a href="#2-GC判断对象是否可以回收" class="headerlink" title="2.GC判断对象是否可以回收"></a>2.GC判断对象是否可以回收</h2><h3 id="2-1-引用计数（已淘汰）"><a href="#2-1-引用计数（已淘汰）" class="headerlink" title="2.1 引用计数（已淘汰）"></a>2.1 引用计数（已淘汰）</h3><p>引用计数算法就是看对象是否被引用。如果引用则对象计数器加一。如果释放引用计数器减一。但是引用计数算法最大的问题就是循环引用问题。当出现循环引用时对象计数器至少为1.这时候对象可能已经是垃圾了，但是无法被回收。</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902163226480.png" alt="image-20230902163226480"></p>
<h3 id="2-2-可达性分析"><a href="#2-2-可达性分析" class="headerlink" title="2.2 可达性分析"></a>2.2 可达性分析</h3><p>可达性算法没有引用计数算法中循环引用无法被回收的问题。</p>
<p>其主要思路是通过一系列名为GC Roots的对象作为根，从根开始往下搜索，搜索过程经过的路径称为引用链（Reference Chain），当一个对象到达GC Roots时表示当前对象还在使用，如果没有引用的或者和其他非GC Roots循环引用的内容都是垃圾。静态变量、线程变量、常量池、JNI（指针）都是GC Roots</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902163316199.png" alt="image-20230902163316199"></p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902163324869.png" alt="image-20230902163324869"></p>
<h2 id="3-GC回收算法"><a href="#3-GC回收算法" class="headerlink" title="3. GC回收算法"></a>3. GC回收算法</h2><h3 id="3-1-标记清除算法-Mark-sweep"><a href="#3-1-标记清除算法-Mark-sweep" class="headerlink" title="3.1 标记清除算法(Mark-sweep)"></a>3.1 标记清除算法(Mark-sweep)</h3><p>先标记出所有需要回收的对象。标记完成后统一回收所有标记的对象。</p>
<p>缺点：内存碎片多（造成不连续的内存空间）。</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902163616483.png" alt="image-20230902163616483"></p>
<h3 id="3-2-标记压缩算法（Mark-Compact）"><a href="#3-2-标记压缩算法（Mark-Compact）" class="headerlink" title="3.2 标记压缩算法（Mark-Compact）"></a>3.2 标记压缩算法（Mark-Compact）</h3><p>又叫标记整理算法。</p>
<p>和标记清除算法类似。主要区别是标记完成后并不会直接清除，而是把所有不回收对象先向一端移动，然后在清除掉边界外面的对象。这样就不会产生内存碎片。</p>
<img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\image-20230902163714468.png" alt="image-20230902163714468" style="zoom: 67%;" />

<h3 id="3-3-复制算法（copying）"><a href="#3-3-复制算法（copying）" class="headerlink" title="3.3 复制算法（copying）"></a>3.3 复制算法（copying）</h3><p>目的：为了解决标记清除算法的碎片问题。</p>
<p>步骤：内存按照容量分为大小相等的两块。每次只使用一块。当一块使用完成后，把存活的对象复制到另一个空间，然后把空间一次清除掉。</p>
<p>缺点：可用内存减少。</p>
<h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>把堆分为新生代和老年代。</p>
<p>新生代采用一种算法，老年代采用一种算法。具体新生代和老年代采用的算法需要看使用的哪种辣鸡回收器。</p>
<h2 id="4-GC种类"><a href="#4-GC种类" class="headerlink" title="4. GC种类"></a>4. GC种类</h2><h3 id="4-1-种类"><a href="#4-1-种类" class="headerlink" title="4.1 种类"></a>4.1 种类</h3><img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\image-20230902164037597.png" alt="image-20230902164037597" style="zoom: 80%;" />

<h3 id="4-2-可以组合的关系"><a href="#4-2-可以组合的关系" class="headerlink" title="4.2 可以组合的关系"></a>4.2 可以组合的关系</h3><img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\image-20230902164147153.png" alt="image-20230902164147153" style="zoom: 80%;" />

<h2 id="5-GC-详细介绍"><a href="#5-GC-详细介绍" class="headerlink" title="5.GC 详细介绍"></a>5.GC 详细介绍</h2><h3 id="5-1-Serial、Serial-Old-串行收集器"><a href="#5-1-Serial、Serial-Old-串行收集器" class="headerlink" title="5.1 Serial、Serial Old 串行收集器"></a>5.1 Serial、Serial Old 串行收集器</h3><h4 id="5-1-1-Serial-收集器"><a href="#5-1-1-Serial-收集器" class="headerlink" title="5.1.1 Serial 收集器"></a>5.1.1 Serial 收集器</h4><p>起源于JDK 1.3，单线程执行，每次回收必须STW。</p>
<p>应用场景：虚拟机在client模式下默认的GC。</p>
<p>优点：简单高效。</p>
<h4 id="5-1-2-Serial-Old-收集器"><a href="#5-1-2-Serial-Old-收集器" class="headerlink" title="5.1.2 Serial Old 收集器"></a>5.1.2 Serial Old 收集器</h4><p>老年代收集器。标记整理算法。单线程。主要应用在client模式下老年代收集。在JDK1.5之前可以与Parallel Scavenge配合使用。可作为CMS的备选。</p>
<p><img src="C:\Users\83753\Desktop#笔记总结\JVM\img\image-20230902164323690.png" alt="image-20230902164323690"></p>
<h3 id="5-2-ParNew-收集器"><a href="#5-2-ParNew-收集器" class="headerlink" title="5.2 ParNew 收集器"></a>5.2 ParNew 收集器</h3><p>Serial 收集器多线程版本，用于收集新生代。可与CMS配合使用。</p>
<p>ParNew可以并行执行，主要为了减少STW的时间，加快程序响应，给用户提供良好的体验。</p>
<h3 id="5-3-Parallel-Scavenge-收集器"><a href="#5-3-Parallel-Scavenge-收集器" class="headerlink" title="5.3 Parallel Scavenge 收集器"></a>5.3 Parallel Scavenge 收集器</h3><p>新生代收集器。采用复制算法。可以并行执行。</p>
<p>优点：</p>
<p>​	具备自适应调节能力。-XX:+UseAdaptiveSizePolicy</p>
<p>​	主要解决吞吐量问题。也被称为“吞吐量优先”收集器。即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间），<a target="_blank" rel="noopener" href="https://www.2cto.com/os/xuniji/">虚拟机</a>总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。高吞吐量可以高效的利用CPU时间，尽快完成运算任务。</p>
<h3 id="5-4-Parallel-Old-收集器"><a href="#5-4-Parallel-Old-收集器" class="headerlink" title="5.4 Parallel Old 收集器"></a>5.4 Parallel Old 收集器</h3><p>老年代收集器。标记整理算法。多线程。JDK 1.6中出现。</p>
<h3 id="5-5-CMS收集器（Concurrent-Mark-Sweep-Collector）"><a href="#5-5-CMS收集器（Concurrent-Mark-Sweep-Collector）" class="headerlink" title="5.5 CMS收集器（Concurrent Mark-Sweep Collector）"></a>5.5 CMS收集器（Concurrent Mark-Sweep Collector）</h3><h4 id="5-5-1介绍"><a href="#5-5-1介绍" class="headerlink" title="5.5.1介绍"></a>5.5.1介绍</h4><p>主要为了减少STW时间。</p>
<h4 id="5-5-2步骤"><a href="#5-5-2步骤" class="headerlink" title="5.5.2步骤"></a>5.5.2步骤</h4><p>采用标记清除算法：<br>初始标记：初始标记只是标记下GC Roots能够关联的对象。速度很快。需要STW<br>并发标记：进行GC Roots Tracing的过程。不需要STW<br>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。需要STW<br>并发清除：并发的清除对象。不需要STW</p>
 <img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\27.png" style="zoom:60%;" />

<h4 id="5-5-3优缺点"><a href="#5-5-3优缺点" class="headerlink" title="5.5.3优缺点"></a>5.5.3优缺点</h4><p>优点：<br>​	并发收集。低停顿。<br>​缺点：<br>​	对CPU非常敏感，对于CPU大于4核时要求并发收集时使用的线程数不小于1&#x2F;4。但随着CPU增加而下降。<br>可能产生浮动垃圾。因为CMS清理阶段程序还在运行，所以就可能产生新的垃圾，这部分垃圾只能等到下次才能被清理。所以称为浮动垃圾。<br>​	可能产生大量空间碎片。</p>
<h3 id="5-6-G1收集器（garbage-first）"><a href="#5-6-G1收集器（garbage-first）" class="headerlink" title="5.6 G1收集器（garbage-first）"></a>5.6 G1收集器（garbage-first）</h3><h4 id="5-6-1介绍"><a href="#5-6-1介绍" class="headerlink" title="5.6.1介绍"></a>5.6.1介绍</h4><p>JDK8中主推的收集器。属于CMS的替代品。<br>​G1收集器时堆中的年轻代和老年代只是逻辑上的概念，实际上把堆（一块连续内存）分为很多Region（分区）每个分区里面又被分为多个卡片（Card）。所以里面可能有很多年轻代和老年代。G1收集器里面多了一个新的概念：humongous（巨型对象）。当对象达到或超过Region一半时称为巨型对象。巨行对象独占一个或多个连续的Region。</p>
 <img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\28.png" style="zoom:70%;" />

<h4 id="5-6-2步骤："><a href="#5-6-2步骤：" class="headerlink" title="5.6.2步骤："></a>5.6.2步骤：</h4><ol>
<li>初始标记：初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值。此过程需要STW，但是耗时很短。</li>
<li>并发标记：并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象。此过程耗时可能较长于用户操作并发执行，不需要STW。</li>
<li>重新标记。标记因为并发标记时用户执行产生的垃圾。需要STW（也可以并行）</li>
<li>筛选回收。对各个Region收回价值和时间进行计算，筛选出符合用户设定的预期回收时间。</li>
</ol>
 <img src="C:\Users\83753\Desktop\#笔记总结\JVM\img\29.png" style="zoom:60%;" />

<h2 id="6-G1收集器和CMS收集器的区别"><a href="#6-G1收集器和CMS收集器的区别" class="headerlink" title="6. G1收集器和CMS收集器的区别"></a>6. G1收集器和CMS收集器的区别</h2><ol>
<li>G1是用在新生代和老年代同时使用。CMS是老年代收集器。</li>
<li>G1是Java8主推的收集器。CMS是java5出现的收集器。</li>
<li>G1的STW时间可由用户设定，在筛选回收过程“可预测”的想办法满足设定要求。CMS是尽可能的减少STW时间</li>
<li>G1使用的是标记整理算法，CMS使用的是标记清除算法（所以可能有内存碎片）。</li>
<li>G1回收的流程是初始标记、并发标记、最终标记、筛选回收。CMS的流程是：初始标记、并发标记、重新标记、并发清除。</li>
</ol>

</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
              <a href="/2023/09/04/My-new-Post/">
                My new Post
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>
	<a href="/">Young</a> 
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>